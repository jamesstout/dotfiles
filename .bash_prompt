# fmt_time () { #format time just the way I likes it
#     if [ `date +%p` = "PM" ]; then
#         meridiem="pm"
#     else
#         meridiem="am"
#     fi
#     date +"%l:%M:%S$meridiem"|sed 's/ //g'
# }
# pwdtail () { #returns the last 2 fields of the working directory
#     pwd|awk -F/ '{nlast = NF -1;print $nlast"/"$NF}'
# }
# chkload () { #gets the current 1m avg CPU load
#     local CURRLOAD=`uptime|awk '{print $8}'`
#     if [ "$CURRLOAD" > "1" ]; then
#         local OUTP="HIGH"
#     elif [ "$CURRLOAD" < "1" ]; then
#         local OUTP="NORMAL"
#     else
#         local OUTP="UNKNOWN"
#     fi
#     echo $CURRLOAD
# }

# prompt_command () {
#     if [ $? -eq 0 ]; then # set an error string for the prompt, if applicable
#         ERRPROMPT=" "
#     else
#         ERRPROMPT='->($?) '
#     fi
#     if [ "\$(type -t __git_ps1)" ]; then # if we're in a Git repo, show current branch
#         BRANCH="\$(__git_ps1 '[ %s ] ')"
#     fi
#     local TIME=`fmt_time` # format time for prompt string
#     local LOAD=`uptime|awk '{min=NF-2;print $min}'`
#     local GREEN="\[\033[0;32m\]"
#     local CYAN="\[\033[0;36m\]"
#     local BCYAN="\[\033[1;36m\]"
#     local BLUE="\[\033[0;34m\]"
#     local GRAY="\[\033[0;37m\]"
#     local DKGRAY="\[\033[1;30m\]"
#     local WHITE="\[\033[1;37m\]"
#     local RED="\[\033[0;31m\]"
#     # return color to Terminal setting for text color
#     local DEFAULT="\[\033[0;39m\]"
#     # set the titlebar to the last 2 fields of pwd
#     local TITLEBAR='\[\e]2;`pwdtail`\a'
#     export PS1="\[${TITLEBAR}\]${CYAN}[ ${BCYAN}\u${GREEN}@${BCYAN}\
# \h${DKGRAY}(${LOAD}) ${WHITE}${TIME} ${CYAN}]${RED}$ERRPROMPT${GRAY}\
# \w\n${GREEN}${BRANCH}${DEFAULT}$ "
# }

# PROMPT_COMMAND2=prompt_command


# # Make new shells get the history lines from all previous
# # shells instead of the default "last window closed" history
# PROMPT_COMMAND='history 1 >> ${HOME}/.bash_eternal_history'
# PROMPT_COMMAND="history -a; $PROMPT_COMMAND; $PROMPT_COMMAND2"


# @gf3’s Sexy Bash Prompt, inspired by “Extravagant Zsh Prompt”
# Shamelessly copied from https://github.com/gf3/dotfiles and 
# https://github.com/necolas/dotfiles/blob/master/bash/bash_prompt
# Screenshot: http://i.imgur.com/s0Blh.png

if [[ $COLORTERM = gnome-* && $TERM = xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then
	export TERM=gnome-256color
elif infocmp xterm-256color >/dev/null 2>&1; then
	export TERM=xterm-256color
fi

tput sgr 0 0

# Base styles and color palette
# Solarized colors
# https://github.com/altercation/solarized/tree/master/iterm2-colors-solarized
BOLD=$(tput bold)
RESET=$(tput sgr0)
SOLAR_YELLOW=$(tput setaf 136)
SOLAR_ORANGE=$(tput setaf 166)
SOLAR_RED=$(tput setaf 124)
SOLAR_MAGENTA=$(tput setaf 125)
SOLAR_VIOLET=$(tput setaf 61)
SOLAR_BLUE=$(tput setaf 33)
SOLAR_CYAN=$(tput setaf 37)
SOLAR_GREEN=$(tput setaf 64)
SOLAR_WHITE=$(tput setaf 254)

style_user="\[${RESET}${SOLAR_ORANGE}\]"
style_host="\[${RESET}${SOLAR_YELLOW}\]"
style_path="\[${RESET}${SOLAR_GREEN}\]"
style_chars="\[${RESET}${SOLAR_WHITE}\]"
style_branch="${SOLAR_CYAN}"

if [[ "$SSH_TTY" ]]; then
    # connected via ssh
    style_host="\[${BOLD}${SOLAR_RED}\]"
elif [[ "$USER" == "root" ]]; then
    # logged in as root
    style_user="\[${BOLD}${SOLAR_RED}\]"
fi

is_git_repo() {
    $(git rev-parse --is-inside-work-tree &> /dev/null)
}

is_git_dir() {
    $(git rev-parse --is-inside-git-dir 2> /dev/null)
}

get_git_branch() {
    local branch_name

    # Get the short symbolic ref
    branch_name=$(git symbolic-ref --quiet --short HEAD 2> /dev/null) ||
    # If HEAD isn't a symbolic ref, get the short SHA
    branch_name=$(git rev-parse --short HEAD 2> /dev/null) ||
    # Otherwise, just give up
    branch_name="(unknown)"

    printf $branch_name
}

# Git status information
prompt_git() {
    local git_info git_state uc us ut st

    if ! is_git_repo || is_git_dir; then
        return 1
    fi

    # ensure index is up to date
    git update-index --really-refresh  -q &>/dev/null

    git_info=$(get_git_branch)

    # remember git will ignore empty dirs
    # unless they contain a .gitignore file
    # so the prompt should be correct
    # with the caveat that it ignores any new empty folders

    # Check for uncommitted changes in the index
    if ! $(git diff --quiet --ignore-submodules --cached); then
        uc="+"
    fi

    # Check for unstaged changes
    if ! $(git diff-files --quiet --ignore-submodules --); then
        us="!"
    fi

    # Check for untracked files
    if [ -n "$(git ls-files --others --exclude-standard)" ]; then
        ut="?"
    fi

    # Check for stashed files
    if $(git rev-parse --verify refs/stash &>/dev/null); then
        st="$"
    fi

    git_state=$uc$us$ut$st

    # Combine the branch name and state information
    if [[ $git_state ]]; then
        git_info="$git_info[$git_state]"
    fi

    printf "${SOLAR_WHITE} on ${style_branch}${git_info}"
}

# Make new shells get the history lines from all previous
# shells instead of the default "last window closed" history
PROMPT_COMMAND='history 1 >> ${HOME}/.bash_eternal_history'
PROMPT_COMMAND="history -a; $PROMPT_COMMAND"

# Set the terminal title to the current working directory
#PS1="\[\033]0;\h: \w\007\]"
PS1="\[\033]0;\w\007\]"
# Build the prompt
PS1+="\n" # Newline
PS1+="${style_user}\u" # Username
PS1+="${style_chars}@" # @
PS1+="${style_host}\h" # Host
PS1+="${style_chars}: " # :
PS1+="${style_path}\w" # Working directory
PS1+="\$(prompt_git)" # Git details
PS1+="\n" # Newline
PS1+="${style_chars}\$ \[${RESET}\]" # $ (and reset color)