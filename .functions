# shellcheck shell=bash
function show-empty-folders {
    find . -depth -type d -empty
}

function kill-empty-folders {
    find . -depth -type d -empty -exec rmdir "{}" \;
}

function git-root {
  root=$(git rev-parse --git-dir 2> /dev/null)
  [[ -z "$root" ]] && root="."
  dirname $root
}

# Show the top 10 processes.
function top10 {
	# Default columns displayed by "top" on Debian Linux and Mac OS X:
	#         1   2    3  4  5    6   7   8 9    10   11    12
	# Linux:  PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND
	# Darwin: PID COMMAND %CPU TIME #TH #WQ #PORTS #MREGS RPRVT RSHRD RSIZE VPRVT VSIZE PGRP PPID STATE UID FAULTS COW MSGSENT MSGRECV SYSBSD SYSMACH CSW PAGEINS USER
	#         1   2       3    4    5   6   7      8      9     10    11    12    13    14   15   16    17  18     19  20      21      22     23      24  25      26
	if [[ "$OSTYPE" =~ ^darwin ]]; then
		# Mac OS X's top does not calculate the CPU usage when sampling only
		# once. So, sample twice and only keep the output of the second
		# sample. This makes it seem very slow, but them's the breaks.
		local output="";
		output="$(top -l 2 -n 10 -o CPU -stats pid,user,cpu,vsize,state,time,command)";
		output="$(tail -n "$(($(wc -l <<< "$output") / 2))" <<< "$output")";
	else
		# Debian's top (and possibly other Linux versions) does not allow
		# requesting specific fields on the command line, so create a
		# temporary .toprc somewhere and use that. The "fieldscur" below
		# correspond to the "-stats" option for OS X's "top". See above.
		local tmp_dir="";
		tmp_dir="$(mktemp -d -t "top10.$$.XXXX")";
		cat > "$tmp_dir/.toprc" <<-EOD
			RCfile for "top with windows"		# shameless braggin'
			Id:a, Mode_altscr=0, Mode_irixps=1, Delay_time=3.000, Curwin=0
			Def	fieldscur=AEKhiOQTWnMbcdfgjplrsuvyzX
				winflags=62777, sortindx=10, maxtasks=0
				summclr=1, msgsclr=1, headclr=3, taskclr=1
		EOD
		local output="";
		output="$(HOME="$tmp_dir"; top -bn 1)";
		rm -rf "$tmp_dir";
	fi;

	# Output the result, and use "column" to align the process columns a bit
	# better than "top" itself does. This does screw up the command names when
	# they contain a space, e.g. "Chromium Helper" => "Chromium     Helper".
	local pid_start_line="$(egrep -nm1 '^\s*PID' <<< "$output" || echo 65536)";
	pid_start_line="${pid_start_line%:*}";
	head -n $((pid_start_line - 1)) <<< "$output";
	tail -n +$pid_start_line <<< "$output" | head -n 11 | column -t;
}

# Change working directory to the top-most Finder window location
function cdf() { # short for `cdfinder`
	cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')" || exit
}

# Show the given file(s) in the Finder.
function show {
	# Default to the current directory.
	[ $# -eq 0 ] && set -- .;

	# Build the array of paths for AppleScript.
	local path paths=();
	for path; do
		# Make sure each path exists.
		if ! [ -e "$path" ]; then
			echo "show: $path: No such file or directory";
			continue;
		fi;

		# Crappily re-implement "readlink -f" ("realpath") for Darwin.
		# (The "cd ... > /dev/null" hides CDPATH noise.)
		[ -d "$path" ] \
			&& path="$(cd "$path" > /dev/null && pwd)" \
			|| path="$(cd "$(dirname "$path")" > /dev/null && \
			           echo "$PWD/$(basename "$path")")";

		# Use the "POSIX file" AppleScript syntax.
		paths+=("POSIX file \"${path//\"/\"}\"");
	done;
	[ "${#paths[@]}" -eq 0 ] && return;

	# Group all output to pipe through osacript.
	{
		echo 'tell application "Finder"';
		echo -n 'select {'; # "reveal" would select only the last file.

		for ((i = 0; i < ${#paths[@]}; i++)); do
			echo -n "${paths[$i]}";
			[ $i -lt $(($# - 1)) ] && echo -n ', '; # Ugly array.join()...
		done;

		echo '}';
		echo 'activate';
		echo 'end tell';
	} | osascript;
}


# Simple calculator
function calc() {
	local result=""
	result="$(printf "scale=10;$*\n" |  /usr/bin/bc --mathlib | tr -d '\\\n')"
	#                       └─ default (when `--mathlib` is used) is 20
	#
	if [[ "$result" == *.* ]]; then
		# improve the output for decimal numbers
		printf "$result" |
		sed -e 's/^\./0./'        `# add "0" for cases like ".5"` \
		    -e 's/^-\./-0./'      `# add "0" for cases like "-.5"`\
		    -e 's/0*$//;s/\.$//'   # remove trailing zeros
	else
		printf "$result"
	fi
	printf "\n"
}

# Create a new directory and enter it
function mkd() {
	mkdir -p "$@" && cd "$@"
}

# Determine size of a file or total size of a directory
function fs() {
	if du -b /dev/null > /dev/null 2>&1; then
		local arg=-sbh
	else
		local arg=-sh
	fi
	if [[ -n "$@" ]]; then
		du $arg -- "$@"
	else
		du $arg .[^.]* *
	fi
}

#using 1000 not 1024 per Apple: https://support.apple.com/en-hk/HT201402
# converts bytes into something useful
# e.g. 	human-readable 702404
#		685 MiB
function human-readable(){

	local size=$(("$@" + 0));
	for unit in B KiB MiB GiB TiB PiB EiB ZiB YiB; do
		if [ "$size" -lt 1000 ]; then 
			echo -e "${size} ${unit}";
			break;
		fi;
		size=$((size/1000));
	done;

}


# Sort the "du" output and use human-readable units.
function duh {
	du -sk "$@" | sort -n | while read -r size fname; do
		for unit in KiB MiB GiB TiB PiB EiB ZiB YiB; do
			if [ "$size" -lt 1000 ]; then
				echo -e "${size} ${unit}\t${fname}";
				break;
			fi;
			size=$((size/1000));
		done;
	done;
}

function duh-no-git {
	du -sk "$@" | grep -v .git | sort -n | while read -r size fname; do
		for unit in KiB MiB GiB TiB PiB EiB ZiB YiB; do
			if [ "$size" -lt 1000 ]; then
				echo -e "${size} ${unit}\t${fname}";
				break;
			fi;
			size=$((size/1000));
		done;
	done;
}

# Use Git’s colored diff when available
if hash git &>/dev/null; then
	function diff() {
		git diff --no-index --color-words "$@"
	}
fi

## Create a data URL from a file
#function dataurl() {
#	local mimeType=$(file -b --mime-type "$1")
#	if [[ $mimeType == text/* ]]; then
#		mimeType="${mimeType};charset=utf-8"
#	fi
#	echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')"
#}
#
# Start an HTTP server from a directory, optionally specifying the port
function server() {
	local port="${1:-8000}"
	sleep 1 && open "http://localhost:${port}/" &
	# Set the default Content-Type to `text/plain` instead of `application/octet-stream`
	# And serve everything as UTF-8 (although not technically correct, this doesn’t break anything for binary files)
	python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
}

# Start a PHP server from a directory, optionally specifying the port
# (Requires PHP 5.4.0+.)
function phpserver() {
	local port="${1:-4000}"
	local ip=$(ipconfig getifaddr en0)
	sleep 1 && open "http://${ip}:${port}/" &
	php -S "${ip}:${port}"
}

# Compare original and gzipped file size
function gz() {
	local origsize=$(wc -c < "$1")
	local gzipsize=$(gzip -c "$1" | wc -c)
	local ratio=$(echo "$gzipsize * 100/ $origsize" | /usr/bin/bc -l)
	printf "orig: %d bytes\n" "$origsize"
	printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio"
}

# Syntax-highlight JSON strings or files
# Usage: `json '{"foo":42}'` or `echo '{"foo":42}' | json`
function json() {
	if [ -t 0 ]; then # argument
		python -mjson.tool <<< "$*" | pygmentize -l javascript
	else # pipe
		python -mjson.tool | pygmentize -l javascript
	fi
}

# All the dig info
function digga() {
	dig +nocmd "$1" any +multiline +noall +answer
}

# Escape UTF-8 characters into their 3-byte format
function escape() {
	printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u)
	echo # newline
}

# Decode \x{ABCD}-style Unicode escape sequences
function unidecode() {
	perl -e "binmode(STDOUT, ':utf8'); print \"$@\""
	echo # newline
}

# Get a character’s Unicode code point
function codepoint() {
	perl -e "use utf8; print sprintf('U+%04X', ord(\"$@\"))"
	echo # newline
}

# Add note to Notes.app (OS X 10.8)
# Usage: `note 'title' 'body'` or `echo 'body' | note`
# Title is optional
function note() {
	local title
	local body
	if [ -t 0 ]; then
		title="$1"
		body="$2"
	else
		title=$(cat)
	fi
	osascript >/dev/null <<EOF
tell application "Notes"
	tell account "iCloud"
		tell folder "Notes"
			make new note with properties {name:"$title", body:"$title" & "<br><br>" & "$body"}
		end tell
	end tell
end tell
EOF
}

# Add reminder to Reminders.app (OS X 10.8)
# Usage: `remind 'foo'` or `echo 'foo' | remind`
function remind() {
	local text
	if [ -t 0 ]; then
		text="$1" # argument
	else
		text=$(cat) # pipe
	fi
	osascript >/dev/null <<EOF
tell application "Reminders"
	tell the default list
		make new reminder with properties {name:"$text"}
	end tell
end tell
EOF
}

# Manually remove a downloaded app or file from the quarantine
function unquarantine() {
	for attribute in com.apple.metadata:kMDItemDownloadedDate com.apple.metadata:kMDItemWhereFroms com.apple.quarantine; do
		xattr -r -d "$attribute" "$@"
	done
}

# mine

function tz()
{
	TZ_DIR="/usr/share/zoneinfo"

	if [ -n "$OSTYPE" ]; then

		if [[ "$OSTYPE" =~ ^darwin ]] || [[ "$OSTYPE" =~ ^linux ]]; then

			TZ_DIR="/usr/share/zoneinfo"

		elif [[ "$OSTYPE" =~ ^solaris ]]; then

			TZ_DIR="/usr/share/lib/zoneinfo"
		fi
	fi

	if [ ! -d "$TZ_DIR" ]; then
		e_error "$TZ_DIR does not exist"
		exit 1
	fi

	cd "$TZ_DIR"

	# get all the timezones, trim off first 2 chars: "./"
	# store in array for repeat use
	declare -a all_tz=(`find .  | cut -c 3-`)

	# get max len for output formatting
	m=-1
	for x in ${all_tz[@]}
	do
	   if [ ${#x} -gt $m ]
	   then
	      m=${#x}
	   fi
	done

	for index in ${!all_tz[*]}
	do
		export TZ=${all_tz[$index]} 
		xx=`date '+%d %b %I:%M %p'`
		printf "%-*s %s\n" $m "$TZ" "$xx" 
	done

	unset TZ
}

function tzg()
{
	tz | grep -i ${1}
}

function hgu()
{
	file="${HOME}/.bash_eternal_history"
	
	if [ $# -eq 0 -o "$1" = '--help' ] || [ $# -eq 1 -a "$1" = '--' ] || [ $# -gt 3 ] || [ $# -eq 2 ]
	then
		echo 'Usage: hge SEARCH [-t num_lines]'
		return 255
	fi

	if [ $# -eq 1 ]
	then
		cat $file | grep $1 | uniq
		return 0
	fi

	if [ $# -gt 1 ]
	then
	    if [ "$2" = "-t"  ]
	    then
	    	cat $file | grep $1 | uniq | tail -$3
	    fi
	fi
}

function console () {
  if [[ $# > 0 ]]; then
    query=$(echo "$*"|tr -s ' ' '|')
    tail -f /var/log/system.log|grep -i --color=auto -E "$query"
  else
    tail -f /var/log/system.log
  fi
}

urlenc () { #url encode the passed string
  echo -n "$1" | perl -pe's/([^-_.~A-Za-z0-9])/sprintf("%%%02X", ord($1))/seg'
}

fymd () {
  encurl=$(urlenc $1)
  curl "http://fuckyeahmarkdown.com/go/?read=1&preview=0&showframe=0&u=$encurl"|pbcopy
  echo "In your clipboard, man."
}

pman () { #display man page as a PostScript PDF in Preview.app
  man -t "$1"|open -f -a "Preview.app"
}

function imgsize() {
	local width height
	if [[ -f $1 ]]; then
		height=$(sips -g pixelHeight "$1"|tail -n 1|awk '{print $2}')
		width=$(sips -g pixelWidth "$1"|tail -n 1|awk '{print $2}')
		echo "${width} x ${height}"
	else
		echo "File not found"
	fi
}

# gets the current 1m avg CPU load, was part of my prompt,
# but was too slow for prompt_command
chkload () {
  local CURRLOAD=`uptime|awk '{print $(NF-2)}'`
  if [ "$CURRLOAD" > "1" ]; then
    local OUTP="HIGH"
  elif [ "$CURRLOAD" < "1" ]; then
    local OUTP="NORMAL"
  else
    local OUTP="UNKNOWN"
  fi
  echo $CURRLOAD
}

# glorified strip_tags to get plain text from websites
# no markdownify
function webtext() {
  curl -s "$1"|php -r "echo trim(html_entity_decode(preg_replace('/([\n\s])+/misx',' ',strip_tags(preg_replace('/<script.*?\/script>/misx','',file_get_contents('php://stdin')))),ENT_QUOTES));"
}

# get any apps full-size icon, compression via jpegtran
function geticon() {
  # Autocompletes app names with modified .app_completions scripts
  APP=`echo $1|sed -e 's/\.app$//'`
  APPDIR=''
  for dir in "/Applications/" "/Applications/Utilities/" "/Developer/Applications/" "/Developer/Applications/Utilties/"; do
    if [[ -d ${dir}$APP.app ]]; then
        APPDIR=$dir
        break
    fi
  done
  if [[ $APPDIR == '' ]]; then
    echo "App not found"
  else
    ICON=`defaults read "${APPDIR}$APP.app/Contents/Info" CFBundleIconFile|sed -e 's/\.icns$//'`
    TMPFILE="${TMPDIR}${APP}_icon.jpg"
    OUTFILE="$HOME/Desktop/${APP}_icon.jpg"
    MAXAVAIL=`sips -g pixelWidth "${APPDIR}$APP.app/Contents/Resources/$ICON.icns"|tail -1|awk '{print $2}'`
    echo -n "Enter max pixel width ($MAXAVAIL): "
    read MAX
    if [[ $MAX == '' || $MAX -gt $MAXAVAIL ]]; then
      MAX=$MAXAVAIL
    fi
    /usr/bin/sips -s format jpeg --resampleHeightWidthMax $MAX "${APPDIR}$APP.app/Contents/Resources/$ICON.icns" --out "$TMPFILE" > /dev/null 2>&1
    /usr/local/bin/jpegtran -optimize "$TMPFILE" > "$OUTFILE"
    echo "Wrote JPG to $OUTFILE."
    echo -n 'Open in Preview? (y/N): '
    read ANSWER
    if [[ $ANSWER == 'y' ]]; then
      open -a "Preview.app" "$OUTFILE"
    fi
  fi
}

# get any app's full-size icon, PNG version
function geticonpng() {
  # Autocompletes app names with modified .app_completions scripts
  APP=`echo $1|sed -e 's/\.app$//'`
  APPDIR=''
  for dir in "/Applications/" "/Applications/Utilities/" "/Developer/Applications/" "/Developer/Applications/Utilties/"; do
    if [[ -d ${dir}$APP.app ]]; then
        APPDIR=$dir
        break
    fi
  done
  if [[ $APPDIR == '' ]]; then
    echo "App not found"
  else
    ICON=`defaults read "${APPDIR}$APP.app/Contents/Info" CFBundleIconFile|sed -e 's/\.icns$//'`
    TMPFILE="${TMPDIR}${APP}_icon.png"
    OUTFILE="$HOME/Desktop/${APP}_icon.png"
    MAXAVAIL=`sips -g pixelWidth "${APPDIR}$APP.app/Contents/Resources/$ICON.icns"|tail -1|awk '{print $2}'`
    echo -n "Enter max pixel width ($MAXAVAIL): "
    read MAX
    if [[ $MAX == '' || $MAX -gt $MAXAVAIL ]]; then
      MAX=$MAXAVAIL
    fi
    /usr/bin/sips -s format png --resampleHeightWidthMax $MAX "${APPDIR}$APP.app/Contents/Resources/$ICON.icns" --out "$OUTFILE" > /dev/null 2>&1
    # /usr/local/bin/jpegtran -optimize "$TMPFILE" > "$OUTFILE"
    echo "Wrote PNG to $OUTFILE."
    echo -n 'Open in Preview? (y/N): '
    read ANSWER
    if [[ $ANSWER == 'y' ]]; then
      open -a "Preview.app" "$OUTFILE"
    fi
  fi
}

# instant web server for current dir
function serve() {
  python -m SimpleHTTPServer ${1:-8080}
}

# Edit and reload the profile.
function pro {

	cd ~/dotfiles
	go working # should always be on working branch
	subl -n -w .{bash_profile,path,exports,aliases,functions,extra,utils};
	source bootstrap.sh
}


function ku()
{
	for app in "Crashlytics" "Calendar" "Contacts" "Dashboard"  \
		"Mail" "Safari" "SizeUp" "SystemUIServer" "Terminal" "Transmission" \
		"Twitter" "iCal" "iTunes" "Cloud" "Dropbox" "Fantastical" "Growl" \
		"HazelHelper" "ChronoSyncBackgrounder" "GeekTool Helper"; do
		killall "$app" > /dev/null 2>&1
	done
}

function psg() 
{
	# exclude the grep process
	# so say we execute psg hello
	# that becomes ps -aef | grep -i [h]ello
	# it's a character class trick. "[h]" does not match "[h]" only "h"
	# so the grep -i [h]ello is ignored
	ps -aef | grep -i "[${1:0:1}]${1:1}"  
	return 0
}

function kpy() 
{
  PY=`ps | grep '[p]yth' | awk '{ print $1 }'`
  echo "Killing python pid: ${PY}"
  kill $PY
  return 0
}

function last() 
{
	if [ "$1" = '--help' ] || [ $# -eq 1 -a "$1" = '--' ] || [ $# -gt 1 ]
	then
		echo 'Usage: last [-t | -c | -tf]'
		echo
		echo 'List the last modified file in a directory and store the filename in an env var: $LAST'
		echo 'Options:'
		echo -e '\t-t  - tail the file'
		echo -e '\t-tf - tail -f the file'
		echo -e '\t-c  - cat the file'
		echo -e '\t-l  - less the file'
		echo -e '\t-v  - vi the file'
		echo -e '\t-cd  - cd into the last item if a directory'
		echo -e '\t-s  - open file with Sublime Text 2'
		return 255
	fi

	shopt -s dotglob #skip . and .. 
	LAST=`ls -lrtd * | grep -v DS_Store | tail -1 |  awk ' { print $9 }'`
	shopt -u dotglob #unset it

	export LAST

	TYPE=`file -b $LAST`

	if [ $# -eq 0 ]; 
		then
		if [ "$TYPE" = "directory" ]
			then
			ls -ld $LAST
		else
			ls -l $LAST
		fi
	
	elif [ "$1" = "-cd" ] && [ "$TYPE" = "directory" ]
		then
			cd $LAST
			pwd

	elif [ "$1" = "-cd" ] && [ "$TYPE" != "directory" ]
		then
			echo "Last item in the directory is a FILE - you can't cd into it"
			ls -l $LAST

	elif [ "$1" = "-s" ] #you can open a dir with subl
		then
			subl -w $LAST &

	elif [ "$TYPE" = "directory" ]	
		then
			echo "Last item in the directory IS a directory - you can't tail/cat/less/vi"
			ls -ld $LAST
	
	elif [ "$1" = "-c" ]
		then
			cat $LAST

	elif [ "$1" = "-t" ]
		then
			tail $LAST

	elif [ "$1" = "-l" ]
		then
			less $LAST

	elif [ "$1" = "-v" ]
		then
			vi $LAST			

	elif [ "$1" = "-tf" ]
		then
			tail -f $LAST
	fi
	
	return 0
}

#########################
## Colorized man pages ##
#########################
man() {
   env \
      LESS_TERMCAP_mb=$(printf "\e[1;31m") \
      LESS_TERMCAP_md=$(printf "\e[1;31m") \
      LESS_TERMCAP_me=$(printf "\e[0m") \
      LESS_TERMCAP_se=$(printf "\e[0m") \
      LESS_TERMCAP_so=$(printf "\e[1;44;33m") \
      LESS_TERMCAP_ue=$(printf "\e[0m") \
      LESS_TERMCAP_us=$(printf "\e[1;32m") \
      man "$@"
}

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
function targz() {
	local tmpFile="${*%/}.tar"
	gtar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1

	size=$(
		stat -f"%z" "${tmpFile}" 2> /dev/null; # OS X `stat`
		stat -c"%s" "${tmpFile}" 2> /dev/null; # GNU `stat`
	)
	
	local cmd=""
	if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
		# the .tar file is smaller than 50 MB and Zopfli is available; use it
		cmd="zopfli"
	else
		if hash pigz 2> /dev/null; then
			cmd="pigz"
		else
			cmd="gzip"
		fi
	fi
	sizeStr=$(human-readable $size);

	PARMS=()

	if [ "$cmd" != "zopfli" ]
	then
		PARMS+=( -9 -v )
	fi

	echo "Compressing .tar ($sizeStr) using \`${cmd} ${PARMS[@]}\`…";
	"${cmd}" "${PARMS[@]}" "${tmpFile}" || return 1
	[ -f "${tmpFile}" ] && rm "${tmpFile}"
	zippedSize=$(
		stat -f"%z" "${tmpFile}.gz" 2> /dev/null; # OS X `stat`
		stat -c"%s" "${tmpFile}.gz" 2> /dev/null; # GNU `stat`
	);

	zippedSizeStr=$(human-readable $zippedSize);

	echo "${tmpFile}.gz ($zippedSizeStr) created successfully";
}

################
## Smarter CD ##
################
function goto() {
   [[ -d "$1" ]] && { cd "$1"; } || cd "$(dirname "$1")";
}

function gt() {
   [[ -d "$1" ]] && { cd "$1"; } || cd "$(dirname "$1")";
}

####################
## Copy && Follow ##
####################
function cpf() {
   cp "$@" && goto "$_";
}

####################
## Move && Follow ##
####################
function mvf() {
   mv "$@" && goto "$_";
}

#####################
## mkdir && follow ##
#####################
function mkcdr() {
   mkdir -vp "$@" && cd "$_";
}

#####################
## mkdir && follow ##
#####################
function llf() {
   ll "$@" && goto "$_";
}

function wch() 
{
  FP=`which $1`
  echo $FP
  WP=`dirname $FP`
  export WP

  if [ "$2" = "cd" ];
    then
      cd $WP
    fi
}

killPIDS() {

   echo "kill $@"

    kill "$@"
}

sudoKillPIDS() {

    e_warning "Killing with pfexec..."
    echo "pfexec kill $@"
    pfexec kill "$@"
}


function kpu() 
{
	if [ $# -eq 0 -o "$1" = '--help' ] || [ $# -eq 1 -a "$1" = '--' ] || [ $# -gt 1 ] 
	then
		e_warning 'Usage: kp SEARCH_STRING'
		return 255
	fi

	if grep -v '^[-0-9a-zA-Z]*$' <<<$1 ;
	then     
		e_warning 'No regexes! Usage: kp SEARCH_STRING'
		return 255;
	fi

	e_header "Searching for commands matching '$1' ..."

	userID=`id -u`

	psCmd=""

	if [[ "$OSTYPE" =~ ^darwin ]]; 
	then
		psCmd="ps -u $userID"
	else
		psCmd="ps -u $userID -o uid,pid,args"
	fi

	#echo "psCmd = $psCmd"

	# e.g if $1 is 'lib' the grep regex here expands to
	# grep "[l]ib" meaning it won't match *this* grep command
	# it's looking for a command with 'l' followed by 'ib' not grep [l]ib
	# so we don't need to add the usual grep -v grep
	declare -a PID=(`$psCmd | grep "[${1:0:1}]${1:1}" | awk '{ print $2 }'`)

	pidCount=${#PID[@]} 

	if [ $pidCount -gt 0 ]; then
   		echo "$pidCount processes match:"

	   	# list out the processes
	    pidStr=`printf "%s," "${PID[@]}"`
	    ps -f -p $pidStr
	    
	    # check they are really sure
	    seek_confirmation "Are you sure you want to kill all $pidCount processes?"

	    if is_confirmed; then
	      # reformat pidStr without commas - could also do
	      # pidStr=`echo "$pidStr" | rev | cut -c 2- | rev`
	      pidStr=`printf "%s " "${PID[@]}"`

	      killPIDS $pidStr
	      
	    else
	      printf "Aborting...\n"
	      return 0
	    fi   
	  else
	    e_header "No matching processes."
	fi

  return 0


}


function kp() 
{
  if [ $# -eq 0 -o "$1" = '--help' ] || [ $# -eq 1 -a "$1" = '--' ] || [ $# -gt 1 ] 
  then
    e_warning 'Usage: kp SEARCH_STRING'
    return 255
  fi

  if grep -v '^[-0-9a-zA-Z]*$' <<<$1 ;
  then     
      e_warning 'No regexes! Usage: kp SEARCH_STRING'
      return 255;
  fi

  e_header "Searching for commands matching '$1' ..."

  # e.g if $1 is 'lib' the grep regex here expands to
  # grep "[l]ib" meaning it won't match *this* grep command
  # it's looking for a command with 'l' followed by 'ib' not grep [l]ib
  # so we don't need to add the usual grep -v grep
  # using ps -e -o uid,pid,comm ensures we don't match the userid with the grep
  declare -a PID=(`ps -e -o uid,pid,comm | grep "[${1:0:1}]${1:1}" | awk '{ print $2 }'`)

  pidCount=${#PID[@]} 

  if [ $pidCount -gt 0 ]; then

    echo "$pidCount processes match:"

    amRoot=0
    userID=`id -u`
    usePFEXEC=0

    if [ "$LOGNAME" = "root" -o "$userID" = "0" ]
    then
      e_warning "You are ROOT - EASY NOW..."
      amRoot=1
    else

      # get the userIDs for the matched processes
      declare -a PID_UID=(`ps -e -o uid,pid,comm | grep "[${1:0:1}]${1:1}" | awk '{ print $1 }'`)

      # remove the current user from the list
      declare -a PID_REMOVEUSER=( ${PID_UID[@]/${userID}/} )

      pidCountAfterRemovingUser=0
      pidCountAfterRemovingUser=${#PID_REMOVEUSER[@]}

      #echo "before = ${PID_UID[@]}"
      #echo "after = ${PID_REMOVEUSER[@]}"
      #echo $pidCountAfterRemovingUser

      # remove root as well - could all be root processes
      declare -a PID_REMOVEROOT=( ${PID_UID[@]/0/} )

      #echo "before = ${PID_UID[@]}"
      #echo "after = ${PID_REMOVEROOT[@]}"  

      pidCountAfterRemovingRoot=0
      pidCountAfterRemovingRoot=${#PID_REMOVEROOT[@]}

      #echo $pidCountAfterRemovingRoot

      # if after removing current user the userId list is different
      # or if all processes belong to root
      # or is after that we still have remaining userIds..
      if [ $pidCountAfterRemovingUser -eq 0 ]
      then
         e_header "All your processes are belong to you..."
      else

        if [ $pidCount -ne $pidCountAfterRemovingUser -o $pidCountAfterRemovingRoot -eq 0 -o $pidCountAfterRemovingRoot -gt 0 ]
        then
          e_warning 'Some matched processes do not belong to you.'

          seek_confirmation "Are you sure you want to continue?"

          if is_confirmed; then
            usePFEXEC=1
          else
            printf "Aborting...\n"
            return 0
          fi   
        else
          e_header "All your processes are belong to you..."
        fi
      fi 
    fi

    # list out the processes
    pidStr=`printf "%s," "${PID[@]}"`
    ps -f -p $pidStr
    
    # check they are really sure
    seek_confirmation "Are you sure you want to kill all $pidCount processes?"

    if is_confirmed; then
      # reformat pidStr without commas - could also do
      # pidStr=`echo "$pidStr" | rev | cut -c 2- | rev`
      pidStr=`printf "%s " "${PID[@]}"`

      if [ $usePFEXEC -ne 1 ]
      then
        killPIDS $pidStr
      else
        sudoKillPIDS $pidStr
      fi
    else
      printf "Aborting...\n"
      return 0
    fi   
  else
    e_header "No matching processes."
  fi

  return 0
}

function extract2 {
 if [ -z "$1" ]; then
    # display usage if no parameters given
    echo "Usage: extract2 <path/file_name>.<zip|rar|bz2|gz|tar|tbz2|tgz|Z|7z|xz|ex|tar.bz2|tar.gz|tar.xz>"
 else
    if [ -f "$1" ] ; then
        local nameInLowerCase=`echo "$1" | awk '{print tolower($0)}'`
        case "$nameInLowerCase" in
          *.tar.bz2)   tar xvjf ./"$1"    ;;
          *.tar.gz)    tar xvzf ./"$1"    ;;
          *.tar.xz)    tar xvJf ./"$1"    ;;
          *.lzma)      unlzma ./"$1"      ;;
          *.bz2)       bunzip2 ./"$1"     ;;
          *.rar)       unrar x -ad ./"$1" ;;
          *.gz)        gunzip ./"$1"      ;;
          *.tar)       tar xvf ./"$1"     ;;
          *.tbz2)      tar xvjf ./"$1"    ;;
          *.tgz)       tar xvzf ./"$1"    ;;
          *.zip)       unzip ./"$1"       ;;
          *.Z)         uncompress ./"$1"  ;;
          *.7z)        7z x ./"$1"        ;;
          *.xz)        unxz ./"$1"        ;;
          *.exe)       cabextract ./"$1"  ;;
          *)           echo "extract: '$1' - unknown archive method" ;;
        esac
    else
        echo "'$1' - file does not exist"
    fi
fi
}


