
# Show the top 10 processes.
function top10 {
	# Default columns displayed by "top" on Debian Linux and Mac OS X:
	#         1   2    3  4  5    6   7   8 9    10   11    12
	# Linux:  PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND
	# Darwin: PID COMMAND %CPU TIME #TH #WQ #PORTS #MREGS RPRVT RSHRD RSIZE VPRVT VSIZE PGRP PPID STATE UID FAULTS COW MSGSENT MSGRECV SYSBSD SYSMACH CSW PAGEINS USER
	#         1   2       3    4    5   6   7      8      9     10    11    12    13    14   15   16    17  18     19  20      21      22     23      24  25      26
	if [[ "$OSTYPE" =~ ^darwin ]]; then
		# Mac OS X's top does not calculate the CPU usage when sampling only
		# once. So, sample twice and only keep the output of the second
		# sample. This makes it seem very slow, but them's the breaks.
		local output="$(top -l 2 -n 10 -o CPU -stats PID,USER,CPU,VSIZE,RSIZE,RSHRD,STATE,TIME,COMMAND)";
		output="$(tail -n "$(($(wc -l <<< "$output") / 2))" <<< "$output")";
	else
		# Debian's top (and possibly other Linux versions) does not allow
		# requesting specific fields on the command line, so create a
		# temporary .toprc somewhere and use that. The "fieldscur" below
		# correspond to the "-stats" option for OS X's "top". See above.
		local tmp_dir="$(mktemp -d -t "top10.$$.XXXX")";
		cat > "$tmp_dir/.toprc" <<-EOD
			RCfile for "top with windows"		# shameless braggin'
			Id:a, Mode_altscr=0, Mode_irixps=1, Delay_time=3.000, Curwin=0
			Def	fieldscur=AEKhiOQTWnMbcdfgjplrsuvyzX
				winflags=62777, sortindx=10, maxtasks=0
				summclr=1, msgsclr=1, headclr=3, taskclr=1
		EOD
		local output="$(HOME="$tmp_dir"; top -bn 1)";
		rm -rf "$tmp_dir";
	fi;

	# Output the result, and use "column" to align the process columns a bit
	# better than "top" itself does. This does screw up the command names when
	# they contain a space, e.g. "Chromium Helper" => "Chromium     Helper".
	local pid_start_line="$(egrep -nm1 '^\s*PID' <<< "$output" || echo 65536)";
	pid_start_line="${pid_start_line%:*}";
	head -n $(($pid_start_line - 1)) <<< "$output";
	tail -n +$pid_start_line <<< "$output" | head -n 11 | column -t;
}

# Change working directory to the top-most Finder window location
function cdf() { # short for `cdfinder`
	cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')"
}

# Show the given file(s) in the Finder.
function show {
	# Default to the current directory.
	[ $# -eq 0 ] && set -- .;

	# Build the array of paths for AppleScript.
	local path paths=();
	for path; do
		# Make sure each path exists.
		if ! [ -e "$path" ]; then
			echo "show: $path: No such file or directory";
			continue;
		fi;

		# Crappily re-implement "readlink -f" ("realpath") for Darwin.
		# (The "cd ... > /dev/null" hides CDPATH noise.)
		[ -d "$path" ] \
			&& path="$(cd "$path" > /dev/null && pwd)" \
			|| path="$(cd "$(dirname "$path")" > /dev/null && \
			           echo "$PWD/$(basename "$path")")";

		# Use the "POSIX file" AppleScript syntax.
		paths+=("POSIX file \"${path//\"/\"}\"");
	done;
	[ "${#paths[@]}" -eq 0 ] && return;

	# Group all output to pipe through osacript.
	{
		echo 'tell application "Finder"';
		echo -n 'select {'; # "reveal" would select only the last file.

		for ((i = 0; i < ${#paths[@]}; i++)); do
			echo -n "${paths[$i]}";
			[ $i -lt $(($# - 1)) ] && echo -n ', '; # Ugly array.join()...
		done;

		echo '}';
		echo 'activate';
		echo 'end tell';
	} | osascript;
}


# Simple calculator
function calc() {
	local result=""
	result="$(printf "scale=10;$*\n" | bc --mathlib | tr -d '\\\n')"
	#                       └─ default (when `--mathlib` is used) is 20
	#
	if [[ "$result" == *.* ]]; then
		# improve the output for decimal numbers
		printf "$result" |
		sed -e 's/^\./0./'        `# add "0" for cases like ".5"` \
		    -e 's/^-\./-0./'      `# add "0" for cases like "-.5"`\
		    -e 's/0*$//;s/\.$//'   # remove trailing zeros
	else
		printf "$result"
	fi
	printf "\n"
}

# Create a new directory and enter it
function mkd() {
	mkdir -p "$@" && cd "$@"
}

# Determine size of a file or total size of a directory
function fs() {
	if du -b /dev/null > /dev/null 2>&1; then
		local arg=-sbh
	else
		local arg=-sh
	fi
	if [[ -n "$@" ]]; then
		du $arg -- "$@"
	else
		du $arg .[^.]* *
	fi
}

# Sort the "du" output and use human-readable units.
function duh {
	du -sk "$@" | sort -n | while read size fname; do
		for unit in KiB MiB GiB TiB PiB EiB ZiB YiB; do
			if [ "$size" -lt 1024 ]; then
				echo -e "${size} ${unit}\t${fname}";
				break;
			fi;
			size=$((size/1024));
		done;
	done;
}


# Use Git’s colored diff when available
hash git &>/dev/null
if [ $? -eq 0 ]; then
	function diff() {
		git diff --no-index --color-words "$@"
	}
fi

## Create a data URL from a file
#function dataurl() {
#	local mimeType=$(file -b --mime-type "$1")
#	if [[ $mimeType == text/* ]]; then
#		mimeType="${mimeType};charset=utf-8"
#	fi
#	echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')"
#}
#
## Start an HTTP server from a directory, optionally specifying the port
#function server() {
#	local port="${1:-8000}"
#	sleep 1 && open "http://localhost:${port}/" &
#	# Set the default Content-Type to `text/plain` instead of `application/octet-stream`
#	# And serve everything as UTF-8 (although not technically correct, this doesn’t break anything for binary files)
#	python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
#}
#
## Start a PHP server from a directory, optionally specifying the port
## (Requires PHP 5.4.0+.)
#function phpserver() {
#	local port="${1:-4000}"
#	local ip=$(ipconfig getifaddr en1)
#	sleep 1 && open "http://${ip}:${port}/" &
#	php -S "${ip}:${port}"
#}

# Compare original and gzipped file size
function gz() {
	local origsize=$(wc -c < "$1")
	local gzipsize=$(gzip -c "$1" | wc -c)
	local ratio=$(echo "$gzipsize * 100/ $origsize" | bc -l)
	printf "orig: %d bytes\n" "$origsize"
	printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio"
}

# Test if HTTP compression (RFC 2616 + SDCH) is enabled for a given URL.
# Send a fake UA string for sites that sniff it instead of using the Accept-Encoding header. (Looking at you, ajax.googleapis.com!)
function httpcompression() {
	encoding="$(curl -LIs -H 'User-Agent: Mozilla/5 Gecko' -H 'Accept-Encoding: gzip,deflate,compress,sdch' "$1" | grep '^Content-Encoding:')" && echo "$1 is encoded using ${encoding#* }" || echo "$1 is not using any encoding"
}

# Syntax-highlight JSON strings or files
# Usage: `json '{"foo":42}'` or `echo '{"foo":42}' | json`
function json() {
	if [ -t 0 ]; then # argument
		python -mjson.tool <<< "$*" | pygmentize -l javascript
	else # pipe
		python -mjson.tool | pygmentize -l javascript
	fi
}

# All the dig info
function digga() {
	dig +nocmd "$1" any +multiline +noall +answer
}

# Escape UTF-8 characters into their 3-byte format
function escape() {
	printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u)
	echo # newline
}

# Decode \x{ABCD}-style Unicode escape sequences
function unidecode() {
	perl -e "binmode(STDOUT, ':utf8'); print \"$@\""
	echo # newline
}

# Get a character’s Unicode code point
function codepoint() {
	perl -e "use utf8; print sprintf('U+%04X', ord(\"$@\"))"
	echo # newline
}

# Add note to Notes.app (OS X 10.8)
# Usage: `note 'foo'` or `echo 'foo' | note`
function note() {
	local text
	if [ -t 0 ]; then # argument
		text="$1"
	else # pipe
		text=$(cat)
	fi
	body=$(echo "$text" | sed -E 's|$|<br>|g')
	osascript >/dev/null <<EOF
tell application "Notes"
	tell account "iCloud"
		tell folder "Notes"
			make new note with properties {name:"$text", body:"$body"}
		end tell
	end tell
end tell
EOF
}

# Add reminder to Reminders.app (OS X 10.8)
# Usage: `remind 'foo'` or `echo 'foo' | remind`
function remind() {
	local text
	if [ -t 0 ]; then
		text="$1" # argument
	else
		text=$(cat) # pipe
	fi
	osascript >/dev/null <<EOF
tell application "Reminders"
	tell the default list
		make new reminder with properties {name:"$text"}
	end tell
end tell
EOF
}

# Manually remove a downloaded app or file from the quarantine
function unquarantine() {
	for attribute in com.apple.metadata:kMDItemDownloadedDate com.apple.metadata:kMDItemWhereFroms com.apple.quarantine; do
		xattr -r -d "$attribute" "$@"
	done
}

# mine

function hgu()
{
	file="${HOME}/.bash_eternal_history"
	
	if [ $# -eq 0 -o "$1" = '--help' ] || [ $# -eq 1 -a "$1" = '--' ] || [ $# -gt 3 ] || [ $# -eq 2 ]
	then
		echo 'Usage: hge SEARCH [-t num_lines]'
		return 255
	fi

	if [ $# -eq 1 ]
	then
		cat $file | grep $1 | uniq
		return 0
	fi

	if [ $# -gt 1 ]
	then
	    if [ "$2" = "-t"  ]
	    then
	    	cat $file | grep $1 | uniq | tail -$3
	    fi
	fi
}


# Edit and reload the profile.
function pro {

	cd ~/dotfiles
	go working # should always be on working branch
	subl -n -w .{bash_profile,path,exports,aliases,functions,extra,utils};
	source bootstrap.sh
}


function ku()
{
	for app in "Crashlytics" "Calendar" "Contacts" "Dashboard"  \
		"Mail" "Safari" "SizeUp" "SystemUIServer" "Terminal" "Transmission" \
		"Twitter" "iCal" "iTunes" "Cloud" "Dropbox" "Fantastical" "Growl" \
		"HazelHelper" "ChronoSyncBackgrounder" "GeekTool Helper"; do
		killall "$app" > /dev/null 2>&1
	done
}

function psg() 
{
	ps -aef | grep -i "[${1:0:1}]${1:1}"  
	return 0
}

function kpy() 
{
  PY=`ps | grep '[p]yth' | awk '{ print $1 }'`
  echo "Killing python pid: ${PY}"
  kill $PY
  return 0
}

function last() 
{
	if [ "$1" = '--help' ] || [ $# -eq 1 -a "$1" = '--' ] || [ $# -gt 1 ]
	then
		echo 'Usage: last [-t | -c | -tf]'
		echo
		echo 'List the last modified file in a directory and store the filename in an env var: $LAST'
		echo 'Options:'
		echo -e '\t-t  - tail the file'
		echo -e '\t-tf - tail -f the file'
		echo -e '\t-c  - cat the file'
		echo -e '\t-l  - less the file'
		echo -e '\t-v  - vi the file'
		echo -e '\t-cd  - cd into the last item if a directory'
		echo -e '\t-s  - open file with Sublime Text 2'
		return 255
	fi

	shopt -s dotglob #skip . and ..
	LAST=`ls -lrtd * | grep -v DS_Store | tail -1 |  awk ' { print $9 }'`
	shopt -u dotglob #unset it

	TYPE=`file -b $LAST`

	if [ $# -eq 0 ]; 
		then
		if [ "$TYPE" = "directory" ]
			then
			ls -ld $LAST
		else
			ls -l $LAST
		fi
	
	elif [ "$1" = "-cd" ] && [ "$TYPE" = "directory" ]
		then
			cd $LAST
			pwd

	elif [ "$1" = "-cd" ] && [ "$TYPE" != "directory" ]
		then
			echo "Last item in the directory is a FILE - you can't cd into it"
			ls -l $LAST

	elif [ "$1" = "-s" ] #you can open a dir with subl
		then
			subl -w $LAST &

	elif [ "$TYPE" = "directory" ]	
		then
			echo "Last item in the directory IS a directory - you can't tail/cat/less/vi"
			ls -ld $LAST
	
	elif [ "$1" = "-c" ]
		then
			cat $LAST

	elif [ "$1" = "-t" ]
		then
			tail $LAST

	elif [ "$1" = "-l" ]
		then
			less $LAST

	elif [ "$1" = "-v" ]
		then
			vi $LAST			

	elif [ "$1" = "-tf" ]
		then
			tail -f $LAST
	fi
	
	return 0
}

#########################
## Colorized man pages ##
#########################
man() {
   env \
      LESS_TERMCAP_mb=$(printf "\e[1;31m") \
      LESS_TERMCAP_md=$(printf "\e[1;31m") \
      LESS_TERMCAP_me=$(printf "\e[0m") \
      LESS_TERMCAP_se=$(printf "\e[0m") \
      LESS_TERMCAP_so=$(printf "\e[1;44;33m") \
      LESS_TERMCAP_ue=$(printf "\e[0m") \
      LESS_TERMCAP_us=$(printf "\e[1;32m") \
      man "$@"
}

################
## Smarter CD ##
################
function goto() {
   [[ -d "$1" ]] && { cd "$1"; } || cd "$(dirname "$1")";
}

####################
## Copy && Follow ##
####################
function cpf() {
   cp "$@" && goto "$_";
}

####################
## Move && Follow ##
####################
function mvf() {
   mv "$@" && goto "$_";
}

#####################
## mkdir && follow ##
#####################
function mkcdr() {
   mkdir -vp "$@" && cd "$_";
}

#####################
## mkdir && follow ##
#####################
function llf() {
   ll "$@" && goto "$_";
}

function wch() 
{
  FP=`which $1`
  echo $FP
  WP=`dirname $FP`
  export WP

  if [ "$2" = "cd" ];
    then
      cd $WP
    fi
}

killPIDS() {

   echo "kill $@"

    kill "$@"
}

sudoKillPIDS() {

    e_warning "Killing with pfexec..."
    echo "pfexec kill $@"
    pfexec kill "$@"
}


function kpu() 
{
	if [ $# -eq 0 -o "$1" = '--help' ] || [ $# -eq 1 -a "$1" = '--' ] || [ $# -gt 1 ] 
	then
		e_warning 'Usage: kp SEARCH_STRING'
		return 255
	fi

	if grep -v '^[-0-9a-zA-Z]*$' <<<$1 ;
	then     
		e_warning 'No regexes! Usage: kp SEARCH_STRING'
		return 255;
	fi

	e_header "Searching for commands matching '$1' ..."

	userID=`id -u`

	psCmd=""

	if [[ "$OSTYPE" =~ ^darwin ]]; 
	then
		psCmd="ps -u $userID"
	else
		psCmd="ps -u $userID -o uid,pid,args"
	fi

	#echo "psCmd = $psCmd"

	# e.g if $1 is 'lib' the grep regex here expands to
	# grep "[l]ib" meaning it won't match *this* grep command
	# it's looking for a command with 'l' followed by 'ib' not grep [l]ib
	# so we don't need to add the usual grep -v grep
	declare -a PID=(`$psCmd | grep "[${1:0:1}]${1:1}" | awk '{ print $2 }'`)

	pidCount=${#PID[@]} 

	if [ $pidCount -gt 0 ]; then
   		echo "$pidCount processes match:"

	   	# list out the processes
	    pidStr=`printf "%s," "${PID[@]}"`
	    ps -f -p $pidStr
	    
	    # check they are really sure
	    seek_confirmation "Are you sure you want to kill all $pidCount processes?"

	    if is_confirmed; then
	      # reformat pidStr without commas - could also do
	      # pidStr=`echo "$pidStr" | rev | cut -c 2- | rev`
	      pidStr=`printf "%s " "${PID[@]}"`

	      killPIDS $pidStr
	      
	    else
	      printf "Aborting...\n"
	      return 0
	    fi   
	  else
	    e_header "No matching processes."
	fi

  return 0


}


function kp() 
{
  if [ $# -eq 0 -o "$1" = '--help' ] || [ $# -eq 1 -a "$1" = '--' ] || [ $# -gt 1 ] 
  then
    e_warning 'Usage: kp SEARCH_STRING'
    return 255
  fi

  if grep -v '^[-0-9a-zA-Z]*$' <<<$1 ;
  then     
      e_warning 'No regexes! Usage: kp SEARCH_STRING'
      return 255;
  fi

  e_header "Searching for commands matching '$1' ..."

  # e.g if $1 is 'lib' the grep regex here expands to
  # grep "[l]ib" meaning it won't match *this* grep command
  # it's looking for a command with 'l' followed by 'ib' not grep [l]ib
  # so we don't need to add the usual grep -v grep
  # using ps -e -o uid,pid,comm ensures we don't match the userid with the grep
  declare -a PID=(`ps -e -o uid,pid,comm | grep "[${1:0:1}]${1:1}" | awk '{ print $2 }'`)

  pidCount=${#PID[@]} 

  if [ $pidCount -gt 0 ]; then

    echo "$pidCount processes match:"

    amRoot=0
    userID=`id -u`
    usePFEXEC=0

    if [ "$LOGNAME" = "root" -o "$userID" = "0" ]
    then
      e_warning "You are ROOT - EASY NOW..."
      amRoot=1
    else

      # get the userIDs for the matched processes
      declare -a PID_UID=(`ps -e -o uid,pid,comm | grep "[${1:0:1}]${1:1}" | awk '{ print $1 }'`)

      # remove the current user from the list
      declare -a PID_REMOVEUSER=( ${PID_UID[@]/${userID}/} )

      pidCountAfterRemovingUser=0
      pidCountAfterRemovingUser=${#PID_REMOVEUSER[@]}

      #echo "before = ${PID_UID[@]}"
      #echo "after = ${PID_REMOVEUSER[@]}"
      #echo $pidCountAfterRemovingUser

      # remove root as well - could all be root processes
      declare -a PID_REMOVEROOT=( ${PID_UID[@]/0/} )

      #echo "before = ${PID_UID[@]}"
      #echo "after = ${PID_REMOVEROOT[@]}"  

      pidCountAfterRemovingRoot=0
      pidCountAfterRemovingRoot=${#PID_REMOVEROOT[@]}

      #echo $pidCountAfterRemovingRoot

      # if after removing current user the userId list is different
      # or if all processes belong to root
      # or is after that we still have remaining userIds..
      if [ $pidCountAfterRemovingUser -eq 0 ]
      then
         e_header "All your processes are belong to you..."
      else

        if [ $pidCount -ne $pidCountAfterRemovingUser -o $pidCountAfterRemovingRoot -eq 0 -o $pidCountAfterRemovingRoot -gt 0 ]
        then
          e_warning 'Some matched processes do not belong to you.'

          seek_confirmation "Are you sure you want to continue?"

          if is_confirmed; then
            usePFEXEC=1
          else
            printf "Aborting...\n"
            return 0
          fi   
        else
          e_header "All your processes are belong to you..."
        fi
      fi 
    fi

    # list out the processes
    pidStr=`printf "%s," "${PID[@]}"`
    ps -f -p $pidStr
    
    # check they are really sure
    seek_confirmation "Are you sure you want to kill all $pidCount processes?"

    if is_confirmed; then
      # reformat pidStr without commas - could also do
      # pidStr=`echo "$pidStr" | rev | cut -c 2- | rev`
      pidStr=`printf "%s " "${PID[@]}"`

      if [ $usePFEXEC -ne 1 ]
      then
        killPIDS $pidStr
      else
        sudoKillPIDS $pidStr
      fi
    else
      printf "Aborting...\n"
      return 0
    fi   
  else
    e_header "No matching processes."
  fi

  return 0
}

